# DDD-DomainDrivenDesign
[Book]도메인 주도 개발 시작하기(DDD 핵심 개념 정리부터 구현까지), 최범균


# CH 01 : 도메인 모델 시작하기

## 1.2 : 도메인 전문가와 개발자 간 지식 공유
- 개발자는 요구사항을 분석하고 설계하여 코드를 작성하며 테스트 및 배포를 실행한다. 이 과정에서 요구사항은 첫 단추와 같다.
- 요구사항을 제대로 이해하지 않으면 쓸모없거나 유용함이 떨어지는 시스템을 만들기 때문이다.

## 1.3 : 도메인 모델
- 도메인 모델은 특정 도메인을 개념적으로 표현한 것이다.
- 도메인을 이해하려면 도메인이 제공하는 기능과 도메인의 주요 데이터 구성을 파악해야 한다. 이를 가장 잘 보여줄 수 있는 모델이 바로 객체 모델이다.
- 객체 모델 외에도 상태 다이어그램, 클래스 다이어그램 등 UML 표기법을 사용하여 표현할 수도 있다.

![UML 화살표](img.png)
![화살표 설명](img_1.png)

## 1.4 : 도메인 모델 패턴
- 일반적인 애플리케이션 아키텍쳐는 Presentation, Application, Domain, Infrastructure 이렇게 4가지 영역으로 구성된다.
  - Presentation(사용자 인터페이스 또는 표현) : 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 여기서 사용자는 소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템일 수도 있다.
  - Application(응용) : 상용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다.
  - Domain : 시스템이 제공할도메인 규칙을 구현한다.
  - Infrastructure : 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.

<br>

- 마틴 파울러의 "엔터프라이즈 애플리케이션 아키텍처 패턴" 책의 도메인 모델 패턴
  - 이 책의 도메인 모델은 아키텍쳐 상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴을 말한다.
  - 도메인 모델에서 중요한 점은 도메인과 관련된 중요 업무 규칙을 도메인 모델에서 구현한다는 점이다.
  - 핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.

## 1.5 : 도메인 모델 도출
- 아무리 뛰어난 개발자라도 도메인에 대한 이해 없이 코딩을 시작할 수 없다. 기획서, 유스케이스, 사용자 스토리와 같은 요구사항과 관련자와의 대호를 통해 도메인을 이해하고 이리ㅡㄹ 바탕으로 도메인 모델 초안을 만들어야 비로소 코드를 작성할 수 있다.
- 어떤 툴을 사용하든 도메인에 대한 초기 모델이 필요하다
- 도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다. 이 과정은 요구사항에서 출발한다.
- 요구사항을 토대로 명명 규칙, 상태, 제약 규칙, 기능 등을 도출하여 코드에 반영한다.

> 문서화 <br>
문서화를 하는 주된 이유는 지식을 공유하기 위함이다. 실제 구현은 코드에 있으므로 코드를 보면 다 알 수 있지만 코드는 상세한 모든 내용을 다루고 있기 때문에 코드를 이용해서 전체 소프트웨어를 분석하려면 많은 시간을 투자해 야 한다.전반적인 기능 목록이나 모듈 구조, 빌드 과정은 코드를 보고 직접 이해하는 것보다 상위 수준에서 정리한 문서를 참조하는 것이 소프트웨어 전반을 빠르게 이해하는 데 도움이 된다. 전체 구조를 이해하고 더 깊게 이해할 필 요가 있는 부분을 코드로 분석해 나가면 된다.
코드를 보면서 도메인을 깊게 이해하게 되므로 코드 자체도 문서화의 대상이 된다. 도메인 지식이 잘 묻어나도록 코 드를 작성하지 않으면 코드의 동작 과정은 해석할 수 있어도 도메인 관점에서 왜 코드를 그렇게 작성했는지 이해하 는 데는 도움이 되지 않는다. 단순히 코드를 보기 좋게 작성하는 것뿐만 아니라 도메인 관점에서 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아지고 문서로서 코드가 의미를 갖는다.

## 1.6 : 엔티티와 밸류
- 도출한 모델은 크게 엔티티(Entity)와 밸류(Value)로 구분할 수 있다.
- 엔티티(Entity)
  - 엔티티의 가장 큰 특징은 식별자를 가진다는 것이다.
  - 엔티티의 식별자는 바뀌지 않는다. 엔티티를 생성하고 속성을 바꾸고 삭제할 때까지 식별자는 유지된다.
  - 엔티티의 식별자는 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다. 엔티티를 구현한 클래스는 식별자를 이용해서 equals(), hashCode() 메서드를 구현할 수 있다.
- 엔티티의 식별자 생성
  - 특정 규칙에 따라 생성
    - 주문번호, 운송자번호, 카드번호와 같은 식별자는 특정 규칙에 따라 생성한다. 흔히 현재 시간과 다른 값을 조합하여 사용한다. 
  - UUID나 Nano ID와 같은 고유 식별자 생성기 사용
  - 값을 직접 입력
    - 회원의 아이디나 이메일과 같은 식별자는 값을 직접 입력한다. 
  - 일련번호 사용(시퀀스나 DB의 자동 증가 컬럼 사용)
    - 자동증가 컬럼은 DB 테이블에 데이터를 삽입해야 비로소 값을 알 수 있기 때문에 테이블에 데이터를 추가하기 전까지 식별자를 알 수 없다.
    - 이는 엔티티 객체를 생성할 때 식별자를 전달할 수 없음을 의미한다.
    - 하지만 리포지터리(repository)에서 DB가 생성한 식별자를 구해서 엔티티 객체에 반영하기 때문에 크게 신경쓰지 않아도 된다.
- 밸류 타입
   - 밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다. 밸류 타입을 사용하면 개념적으로 완전한 하나를 잘 표현할 수 있다.
   - 밸류 타입을 따로 사용하는 경우 밸류 타입을 위한 기능을 추가할 수도 있다.
   - 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호한다.
   - 데이터의 변경 기능을 제공하지 않는 타입을 불변(immutable)이라고 표현하는데 밸류 타입을 불변으로 구현하면 좋다. 가장 큰 이유는 안전한 코드를 작성할 수 있다는 것이다.
   - 두 밸류 객체를 비교할 때는 equals() 메소드를 이용해 모든 속성이 같은지 비교한다.
- 엔티티 식별자와 밸류 타입
  - 식별자는 단순한 문자열이 많은데, 단순한 문자열이 아니라 도메인에서 특별한 의미를 지니는 밸류 타입을 사용해 그 의미가 잘 드러나도록 할 수 있다.
- Setter 사용
  - Setter를 사용하게 되면 도메인 객체가 불완전한 상태로 사용된다. 
  - 이를 막기 위해 생성 시점에 필요한 것을 전달해 주어야 한다. 즉, 생성자를 통해 필요한 데이터를 모두 받자.
  - 불변 밸류 타입을 사용하면 자연스럽게 밸류 타입에 set 메서드를 구현하지 않게 된다.

## 1.7 : 도메인 용어와 유비쿼터스 언어
- 도메인 용어를 최대한 반영하면 코드를 도메인 용어로 해석하거나 도메인 용어를 코드로 해석하는 과정이 줄어든다.
- 코드의 가독성을 높여서 코드를 분석하고 이해하는 시간을 줄여준다.
- 최대한 도메인 용어를 사용해서 도메인 규칙을 코드로 ㅈ가성하게 되므로(의미를 변환하는 과정에서 발생하는) 버그도 줄어든다.
- 에릭 에반스는 도메인 주도 설ㄱ계에서 언어의 중요함을 강조하기 위해 유비쿼터스 언어(ubiquitous language)라는 용어를 사용했다.
  - 해당 도메인 개발과 관련된 공통의 언어를 만들어 소통 과정에서 발생하는 용어의 모호함을 줄일 수 있고 개발자는 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다.
  - 도메인 용어는 좋은 코드를 만드는 데 매우 중요한 요소이지만 대부분 영어로 되어 있다. 
  - 각 단어의 뉘앙스나 미세한 차이를 이해하고 알맞은 단어를 사용하기 위해 영어 공부를 꼭 해야 할 것이다.

<br>
<hr>
<br>

# CH 02 : 아키텍처 개요

## 2.1 : 네 개의 영역
- 표현, 응용, 도메인, 인프라스트럭처는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역이다.
  - 표현(UI 영역) 
    - 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다. 웹 애플리케이션의 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 해당한다.
    - 웹 애플리켕션의 표현 영역은 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고 응용 영역의 응답을 HTTP 응답으로 변환하여 전송한다.
    - 표현 영역을 통해 사용자의 요청을 전달받는 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 구현한다.
  - 응용 영역
    - 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다.
    - 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
  - 도메인 영역
    - 도메인 모델을 구현한다.
    - 도메인 모델은 도메인의 핵심 로직을 구현한다.
  - 인프라스트럭처
    - 구현 기술에 대한 것을 다룬다.
    - RDBMS 연동을 처리하고 메세징 큐에 메시지를 전송하거나 수신하는 기능을 구현한다.
    - 몽고DB나 레디스와 데이터의 연동을 처리한다.
    - SMTP를 이용한 메일 발송 기능을 구현하거나 HTTP 클라이언트를 이용해서 REST API를 호출하는 것도 처리한다.

## 2.2 : 계층 구조 아키텍처
- 네 영역을 구성할 때 많이 사용하는 아키텍쳐는 계층 구조이다.
- 계층구조는 그 특성상 상위계층(표현)에서 하위 계층(인프라스트럭처)으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.
  - 표현 계층은 응용 계층에 의존하지만 응용 계층은 표현 계층에 의존하지 않는다.
- 계층 구조를 엄격하게 적용한다면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다. 예를 들면 응용계층에서 바로 인프라스트럭처를 의존하는 것이다. 
- 하지만 이렇게 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭처 계층에 종속된다는 문제가 있다.
- 이렇게 인프라스트럭처에 의존하게 되면 "테스트를 하기 어려움"과 "구현 방식을 변경(기능 확장)의 어려움"이라는 문제가 있다.
- 이에 대한 해답은 DIP에 있다.

## 2.3 : DIP
- 고수준 모듈은 의미 있는 단일 기능을 제공하는 모듈이다.
- 저수준 모듈은 고수준 모듈의 하위 기능을 실제로 구현한 것이다.
- 2.2에서의 문제점은 고수준 모듈이 저수준 모듈을 사용하면서 발생한 문제이다. 이를 해결하기 위해 DIP를 사용해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다
- 그렇다면 저수준 모듈이 고수준 모듈에 의존하도록 하려면 어떻게 해야할까? 비밀은 추상화한 인터페이스에 있다.
- 인터페이스(고수준 모듈)을 상속해 실제 구현한 클래스(저수준 모듈)을 사용하면 저수준 모듈이 고수준 모듈에 의존하게 된다.
- 이처럼 저수준 모듈이 고수준 모듈을 의존한다고 해서 DIP(Dependency Inversion Priciple), 의존 역전 원칙이라 한다.
- 스프링과 같은 의존 주입을 지원하는 프레임워크를 사용하면 설정 코드를 수정해서 쉽게 구현체를 변경할 수 있다. 인터페이스를 대역 객체를 사용해 테스트를 진행할 수 있게 된 것이다.
- 실제 구현 없이 테스트를 할 수 있는 이뉴는 DIP를 적용해서 고수준 모듈을 저수준 모듈에 의존하지 않도록 했기 때문이다.


- 주의사항
  - DIP를 잘못 생각하면 단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들일 수 있다.
  - DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.
- DIP와 아키텍처
  - 인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용, 도메인 영역은 고수준 모듈이다. DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.
  - 인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 인터페이스를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.